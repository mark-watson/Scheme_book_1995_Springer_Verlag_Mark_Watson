;; File: Network.s

;;; Network interpreter

(define (match flag wme)
  (sendto flag (list wme) 'left (list *first-node*)))

(define (eval-nodelist nl)
  (while nl
     (begin
        (set! *sendtocall* #f)
        (set! *last-node* (car nl))
        (apply (local-eval (caar nl)) (cdar nl))
        (set! nl (cdr nl)))))

(define (sendto flag data side nl)
   (while nl
     (begin
        (set! *side* side)
        (set! *flag-part* flag)
        (set! *data-part* data)
        (set! *sendtocall* t)
        (set! *last-node* (car nl))
        (apply (local-eval (safe-car (safe-car nl))) (safe-cdr (safe-car nl)))
        (set! nl (safe-cdr nl)))))

; &bus sets up the registers for the one-input nodes.
(define (&bus outs)
   (let ((dp #f))
        (set! *alpha-flag-part* *flag-part*)
        (set! *alpha-data-part* *data-part*)
        (set! dp (safe-car *data-part*))
        (set! *c1* (safe-car dp))
        (set! dp (safe-cdr dp))
        (set! *c2* (safe-car dp))
        (set! dp (safe-cdr dp))
        (set! *c3* (safe-car dp))
        (set! dp (safe-cdr dp))
        (set! *c4* (safe-car dp))
        (set! dp (safe-cdr dp))
        (set! *c5* (safe-car dp))
        (set! dp (safe-cdr dp))
        (set! *c6* (safe-car dp))
     (if
      dp
      (begin
        (set! dp (safe-cdr dp))
        (set! *c7* (safe-car dp))
        (set! dp (safe-cdr dp))
        (set! *c8* (safe-car dp))
        (set! dp (safe-cdr dp))
        (set! *c9* (safe-car dp))
        (set! dp (safe-cdr dp))
        (set! *c10* (safe-car dp))
        (set! dp (safe-cdr dp))
	       (set! *c11* (safe-car dp))
	      	(set! dp (safe-cdr dp))
	      	(set! *c12* (safe-car dp))
	      	(set! dp (safe-cdr dp))
	      	(set! *c13* (safe-car dp))
	       (set! dp (safe-cdr dp))
	      	(set! *c14* (safe-car dp))
	      	(set! dp (safe-cdr dp))
	       (set! *c15* (safe-car dp))
	       (set! dp (safe-cdr dp))
	       (set! *c16* (safe-car dp))
	       (set! dp (safe-cdr dp))
       	(set! *c17* (safe-car dp))
       	(set! dp (safe-cdr dp))
       	(set! *c18* (safe-car dp))
       	(set! dp (safe-cdr dp))
       	(set! *c19* (safe-car dp))
	       (set! dp (safe-cdr dp))
       	(set! *c20* (safe-car dp))
	       (set! dp (safe-cdr dp))
	       (set! *c21* (safe-car dp))
        (set! dp (safe-cdr dp))
	       (set! *c22* (safe-car dp))
	       (set! dp (safe-cdr dp))
       	(set! *c23* (safe-car dp))
       	(set! dp (safe-cdr dp))
	       (set! *c24* (safe-car dp))
	       (set! dp (safe-cdr dp))
       	(set! *c25* (safe-car dp))
	       (set! dp (safe-cdr dp))
	       (set! *c26* (safe-car dp))
	       (set! dp (safe-cdr dp))
	       (set! *c27* (safe-car dp))
	       (set! dp (safe-cdr dp))
	       (set! *c28* (safe-car dp))
        (if
         dp
          (begin
     	       (set! dp (safe-cdr dp))
	            (set! *c29* (safe-car dp))
	            (set! dp (safe-cdr dp))
	            (set! *c30* (safe-car dp))
	            (set! dp (safe-cdr dp))
	            (set! *c31* (safe-car dp))
	            (set! dp (safe-cdr dp))
	            (set! *c32* (safe-car dp))
	            (set! dp (safe-cdr dp))
	            (set! *c33* (safe-car dp))
	            (set! dp (safe-cdr dp))
	            (set! *c34* (safe-car dp))
	            (set! dp (safe-cdr dp))
	            (set! *c35* (safe-car dp))
	            (set! dp (safe-cdr dp))
	            (set! *c36* (safe-car dp))
	            (set! dp (safe-cdr dp))
	            (set! *c37* (safe-car dp))
	            (set! dp (safe-cdr dp))
	            (set! *c38* (safe-car dp))
	            (set! dp (safe-cdr dp))
	            (set! *c39* (safe-car dp))
	            (set! dp (safe-cdr dp))
	            (set! *c40* (safe-car dp))
	            (set! dp (safe-cdr dp))
	            (set! *c41* (safe-car dp))
	            (set! dp (safe-cdr dp))
	            (set! *c42* (safe-car dp))
	            (set! dp (safe-cdr dp))
	            (set! *c43* (safe-car dp))
	            (set! dp (safe-cdr dp))
	            (set! *c44* (safe-car dp))
	            (set! dp (safe-cdr dp))
	            (set! *c45* (safe-car dp))
	            (set! dp (safe-cdr dp))
	            (set! *c46* (safe-car dp))
	            (set! dp (safe-cdr dp))
	            (set! *c47* (safe-car dp))
	            (set! dp (safe-cdr dp))
	            (set! *c48* (safe-car dp))
	            (set! dp (safe-cdr dp))
	            (set! *c49* (safe-car dp))
	            (set! dp (safe-cdr dp))
	            (set! *c50* (safe-car dp))
	            (set! dp (safe-cdr dp))
	            (set! *c51* (safe-car dp))
	            (set! dp (safe-cdr dp))
	            (set! *c52* (safe-car dp))
	            (set! dp (safe-cdr dp))
	            (set! *c53* (safe-car dp))
	            (set! dp (safe-cdr dp))
	            (set! *c54* (safe-car dp))
	            (set! dp (safe-cdr dp))
	            (set! *c55* (safe-car dp))
	            (set! dp (safe-cdr dp))
	            (set! *c56* (safe-car dp))
	            (set! dp (safe-cdr dp))
	            (set! *c57* (safe-car dp))
	            (set! dp (safe-cdr dp))
	            (set! *c58* (safe-car dp))
	            (set! dp (safe-cdr dp))
	            (set! *c59* (safe-car dp))
	            (set! dp (safe-cdr dp))
	            (set! *c60* (safe-car dp))
	            (set! dp (safe-cdr dp))
	            (set! *c61* (safe-car dp))
	            (set! dp (safe-cdr dp))
	            (set! *c62* (safe-car dp))
	            (set! dp (safe-cdr dp))
	            (set! *c63* (safe-car dp))
	            (set! dp (safe-cdr dp))
	            (set! *c64* (safe-car dp))
	            (set! dp (safe-cdr dp))) ))
	    (eval-nodelist outs))))

(define (&any outs register const-list)
  (let ((z (local-eval register)) (c #f))
    
    (define (sym)
      (if (null? const-list)
          #f
          (if (eq? (car const-list) z)
              (eval-nodelist outs)
              (begin
               (set! const-list (cdr const-list))
               (sym)))))
    (define (num)
      (if (null? const-list)
          #f
          (if (and
               (number? (begin (set! c (car const-list)) c))
               (equal? c z))
              (eval-nodelist outs)
              (begin
               (set! const-list (cdr const-list))
               (num)))))
    
    (if (number? z)
        (num)
        (sym))))
    
(define (teqa outs register constant)
  (and (equal? (local-eval register) constant) (eval-nodelist outs)))

(define (teqn outs register constant)
  (let ((z (local-eval register)))
        (and (number? z)
             (equal? z constant)
             (eval-nodelist outs))))

(define (tnea outs register constant)
  (and (not (equal? (local-eval register) constant)) (eval-nodelist outs)))

(define (txxa outs register constant)
  (and (symbol? (local-eval register)) (eval-nodelist outs)))

(define (tnen outs register constant)
  (let ((z (local-eval register)))
       (and (or (not (number? z))
                (not (equal? z constant)))
            (eval-nodelist outs))))

(define (tltn outs register constant)
  (let ((z (local-eval register)))
       (and (number? z)
            (> constant z)
            (eval-nodelist outs))))

(define (tgtn outs register constant)
  (let ((z (local-eval register)))
        (and (number? z)
             (> z constant)
             (eval-nodelist outs))))

(define (tgen outs register constant)
  (let ((z (local-eval register)))
        (and (number? z)
             (not (>  constant z))
             (eval-nodelist outs))))

(define (teqs outs vara varb)
  (let ((a (local-eval vara)) (b (local-eval varb)))
       (cond ((eq? a b) (eval-nodelist outs))
             ((and (number? a)
                   (number? b)
                   (equal? a b))
              (eval-nodelist outs)))))

(define (tnes outs vara varb)
  (let ((a (local-eval vara)) (b (local-eval varb)))
       (cond ((eq a b) #f)
             ((and (number? a)
                   (number? b)
                   (equal? a b))
              #f)
             (t (eval-nodelist outs)))))

(define (teqb new eqvar)
  (cond ((eq? new eqvar) t)
        ((not (number? new)) #f)
        ((not (number? eqvar)) #f)
        ((equal? new eqvar) t)
        (t #f)))

(define (tneb new eqvar)
  (cond ((eq? new eqvar) #f)
        ((not (number? new)) t)
        ((not (number? eqvar)) t)
        ((equal? new eqvar) #f)
        (t t)))

(define (tltb new eqvar)
  (cond ((not (number? new)) #f)
        ((not (number? eqvar)) #f)
        ((> eqvar new) t)
        (t #f)))

(define (tgtb new eqvar)
  (cond ((not (number? new)) #f)
        ((not (number? eqvar)) #f)
        ((> new eqvar) t)
        (t #f)))

(define (tgeb new eqvar)
  (cond ((not (number? new)) #f)
        ((not (number? eqvar)) #f)
        ((not (> eqvar new)) t)
        (t #f)))

(define (tleb new eqvar)
  (cond ((not (number? new)) #f)
        ((not (number? eqvar)) #f)
        ((not (> new eqvar)) t)
        (t #f)))

(define (tlen outs register constant)
  (let ((z (local-eval register)))
       (and (number? z)
            (not (< constant z))
            (eval-nodelist outs))))

(define (txxs outs vara varb)
  (let ((a (local-eval vara)) (b (local-eval varb)))
       (cond ((and (number? a)
		                 (number? b))
	             (eval-nodelist outs))
             ((and (not (number? a)) (not (number? b)))
               (eval-nodelist outs)))))

(define (txxb new eqvar)
  (cond ((number? new)
         (cond ((number? eqvar) t)
               (t #f)))
        (t
         (cond ((number? eqvar) #f)
               (t t)))))

(define (tlts outs vara varb)
  (let ((a (local-eval vara)) (b (local-eval varb)))
       (and (number? a)
            (number? b)
            (< a b)
            (eval-nodelist outs))))

(define (tgts outs vara varb)
  (let ((a (local-eval vara)) (b (local-eval varb)))
       (and (number? a)
            (number? b)
            (< b a)
            (eval-nodelist outs))))

(define (tges outs vara varb)
  (let ((a (local-eval vara)) (b (local-eval varb)))
        (and (number? a)
             (number? b)
             (not (< a b))
             (eval-nodelist outs))))

(define (tles outs vara varb)
  (let ((a (local-eval vara)) (b (local-eval varb)))
       (and (number? a)
            (number? b)
            (not (< b a))
            (eval-nodelist outs))))


(define (&two left-outs right-outs)
  (let ((fp #f) (dp #f))
       (cond (*sendtocall*
              (set! fp *flag-part*)
              (set! dp *data-part*))
             (t
              (set! fp *alpha-flag-part*)
              (set! dp *alpha-data-part*)))
       (sendto fp dp 'left left-outs)
       (sendto fp dp 'right right-outs)))

(define (&mem left-outs right-outs memory-list)
  (let ((fp #f) (dp #f))
       (cond (*sendtocall*
              (set! fp *flag-part*)
              (set! dp *data-part*))
             (t
              (set! fp *alpha-flag-part*)
              (set! dp *alpha-data-part*)))
       (sendto fp dp 'left left-outs)
       (add-token memory-list fp dp #f)
       (sendto fp dp 'right right-outs)))

(define (&and outs lpred rpred tests)
  (let ((mem #f))
       (cond ((eq? *side* 'right) (set! mem (memory-part lpred)))
             (t (set! mem (memory-part rpred))))
       (cond ((not mem) #f)
             ((eq? *side* 'right) (and-right outs mem tests))
             (t (and-left outs mem tests)))))

(define (and-left outs mem tests)
  (let ((fp *flag-part*) (dp *data-part*)
        (memdp #f) (tlist #f) (tst #f) (lind #f) (rind #f) (res #f))
    
   (define (fail)
     (if (not (null? mem))
         (begin
           (set! memdp (car mem))
           (set! mem (cdr mem))
           (set! tlist tests)
           (tloop))))
   (define (tloop)
     (if (null? tlist)
         (succ)
         (begin
           (set! tst (car tlist))
           (set! tlist (cdr tlist))
           (set! lind (car tlist))
           (set! tlist (cdr tlist))
           (set! rind (car tlist))
           (set! tlist (cdr tlist))
           (set!
            res
            (apply (local-eval tst) (list (gelm memdp rind) (gelm dp lind))))
           (if res (tloop) (fail)))))

    (define (succ) 
        (sendto fp (cons (safe-car memdp) dp) 'left outs)
        (fail))
    (fail)))

(define (and-right outs mem tests)
  (let ((fp *flag-part*) (dp *data-part*)
        (memdp #f) (tlist #f) (tst #f) (lind #f) (rind #f) (res #f))
    
   (define (fail)
     (if (not (null? mem))
         (begin
           (set! memdp (car mem))
           (set! mem (cdr mem))
           (set! tlist tests)
           (tloop))))
   (define (tloop)
     (if (null? tlist)
         (succ)
         (begin
           (set! tst (car tlist))
           (set! tlist (cdr tlist))
           (set! lind (car tlist))
           (set! tlist (cdr tlist))
           (set! rind (car tlist))
           (set! tlist (cdr tlist))
           (set!
            res
            (apply (local-eval tst) (list (gelm dp rind) (gelm memdp lind))))
           (if res (tloop) (fail)))))

    (define (succ) 
        (sendto fp (cons (safe-car dp) memdp) 'right outs)
        (fail))
    (fail)))

(define (&p rating name var-dope ce-var-dope rhs)
  (let ((fp #f) (dp #f))
        (cond (*sendtocall*
               (set! fp *flag-part*)
               (set! dp *data-part*))
              (t
               (set! fp *alpha-flag-part*)
               (set! dp *alpha-data-part*)))
        (and (memq fp '(#f #!FALSE old)) (removecs name dp))
        (and fp (insertcs name dp rating))))

(define (&old a b c d e) #f)

(define (&not outs lmem rpred tests)
  (cond ((and (eq *side* 'right) (eq *flag-part* 'old)) #f)
        ((eq *side* 'right) (not-right outs (car lmem) tests))
        (t (not-left outs (memory-part rpred) tests lmem))))

(define (not-left outs mem tests own-mem)
  (let ((fp *flag-part*) (dp *data-part*) (memdp #f) (tlist #f)
        (tst #f) (lind #f) (rind #f) (res #f) (c 0))
    
   (define (fail)
     (if (null? mem)
         (fin)
         (begin
           (set! memdp (car mem))
           (set! mem (cdr mem))
           (set! tlist tests)
           (tloop))))
    
   (define (tloop)
     (if (null? tlist)
         (begin
          (set! c (+ c 1))
          (fail))
         (begin
          (set! tst (car tlist))
          (set! tlist (cdr tlist))
          (set! lind (car tlist))
          (set! tlist (cdr tlist))
          (set! rind (car tlist))
          (set! tlist (cdr tlist))
          (set!
           res
           (apply (local-eval tst) (list (gelm memdp rind) (gelm dp lind))))
          (cond (res (tloop))
                (t (fail))))))
    
   (define (fin)
     (add-token own-mem fp dp c)
     (and (equal? c 0) (sendto fp dp 'left outs)))
    
   (fail)))

(define (not-right outs mem tests)
  (let ((fp *flag-part*) (dp *data-part*) (memdp #f) (tlist #f)
        (tst #f) (lind #f) (rind #f) (res #f) (newc 0)
        (newfp #f) (inc #f))
    
   (define (fail)
     (if (null? mem)
         #f
         (begin
           (set! memdp (car mem))
           (set! mem (cdr mem))
           (set! tlist tests)
           (tloop))))
    
   (define (tloop)
     (if (null? tlist)
         (succ)
         (begin
          (set! tst (car tlist))
          (set! tlist (cdr tlist))
          (set! lind (car tlist))
          (set! tlist (cdr tlist))
          (set! rind (car tlist))
          (set! tlist (cdr tlist))
          (set!
           res
           (apply (local-eval tst) (list (gelm dp rind) (gelm memdp lind))))
          (cond (res (tloop))
                (t (fail)))
          (succ))))
         
    
   (define (succ)
     (set! newc (+ inc newc))
     (if (null? (safe-cdr mem))
         (set! mem (append mem (list newc)))
         (set-car! (cdr mem) newc))
     (cond ((or (and (equal? inc -1) (equal? newc 0))
                (and (equal? inc 1) (equal? newc 1)))
            (sendto newfp memdp 'right outs)))
     (set! mem (safe-cdr (safe-cdr mem)))
     (fail))
    
  (cond ((not fp)
         (set! inc -1)
         (set! newfp 'new)
         (fail))
        ((equal? fp 'new)
         (set! inc 1)
         (set! newfp #f)
         (fail))
        (t #f))))
 

;;; Node memories

(define (add-token memlis flag data-part num)
  (let ((was-present #f))
        (cond ((eq? flag 'new)
               (set! was-present #f)
               (real-add-token memlis data-part num))
              ((not flag) 
               (set! was-present (remove-old memlis data-part num)))
              ((eq? flag 'old) (set! was-present t)))
        was-present))

(define (real-add-token lis data-part num)
  (set! *current-token* (1+ *current-token*))
  (cond (num (set-car! lis (cons num (car lis)))))
  (set-car! lis (cons data-part (car lis))))

(define (remove-old lis data num)
  (cond (num (remove-old-num lis data))
        (t (remove-old-no-num lis data))))
  
(define (remove-old-num lis data)
  (let ((m (car lis)) (next #f) (last #f))
 
   (define (loop)
     (set! last next)
     (set! next (cddr next))
     (cond ((atom? next) #f)
           ((top-levels-eq data (car next))
            (set-cdr! (cdr last) (cddr next))
            (set! *current-token* (sub1 *current-token*))
            (car next))
           (t (loop))))

    (if (atom? m)
        #f
        (if (top-levels-eq data (car m))
            (begin
              (set! *current-token* (sub1 *current-token*))
              (set-car! lis (cddr m))
              (car m))
            (begin
             (set! next m)
             (loop))))))
 
(define (remove-old-no-num lis data)
  (let ((m (car lis)) (next #f) (last #f))
  
      (define (loop)
        (set! last next)
        (set! next (cdr next))
        (cond ((atom? next) #f)
              ((top-levels-eq data (car next))
               (set-cdr! last (cdr next))
               (set! *current-token* (-1+ *current-token*))
               (car next))
              (t (loop))))
  
       (if (atom? m)
           #f
           (if (top-levels-eq data (car m))
               (begin
                 (set! *current-token* (sub1 *current-token*))
                 (set-car! lis (cdr m))
                 (car m))
               (begin
                 (set! next m)
                 (loop))))))

;;; WM functions
  
(define (add-to-wm wme override)
  (let ((fa #f) (z #f) (part #f) (timetag #f) (port #f))
    (set! *critical* t)
    (set! *current-wm* (1+ *current-wm*))
    (and (> *current-wm* *max-wm*) (set! *max-wm* *current-wm*))
    (set! *action-count* (1+ *action-count*))
    (set! fa (wm-hash wme))
    (or (memq fa *wmpart-list*)
        (set! *wmpart-list* (cons fa *wmpart-list*)))
    (set! part (get fa 'wmpart*))
    (cond (override
             (set! timetag override))
          (t (set! timetag *action-count*)))
    (set! z (cons wme timetag))
    (putprop fa (cons z part) 'wmpart*)
    (record-change '=>wm *action-count* wme)
    (match 'new wme)
    (set! *critical* #f)
    (cond ((and *in-rhs* *wtrace*)
           (newline)
           (write "Adding to WM: ")
           (write wme)
           (newline)))))

(define (remove-from-wm wme)
  (let ((fa (wm-hash wme)) (z #f) (part #f) (timetag #f) (port #f))
    (set! part (get fa 'wmpart*))
    (set! z (assq wme part))
    (if z
        (begin
          (set! timetag (cdr z))
          (cond ((and *in-rhs* *wtrace*)
                 (newline)
                 (write "Removing from WM: ")
                 (write wme)
                 (newline)))
          (set! *action-count* (1+ *action-count*))
          (set! *critical* t)
          (set! *current-wm* (-1+ *current-wm*))
          (record-change '<=wm timetag wme)
          (match #f wme)
          (putprop fa (delq z part) 'wmpart*)
          (set! *critical* #f)))))

(define (mapwm fn)
  (let ((wmpl *wmpart-list*) (part #f))
    
   (define (loop)
     (if (atom? wmpl)
         #f
         (begin
           (set! part (get (car wmpl) 'wmpart*))
           (set! wmpl (cdr wmpl))
           (mapc fn part)
           (loop))))    
    
    (loop)))


(define (old-wm a)  ; 2/11/85
  (mapc (lambda (z) (ppelm z))
        (get-wm a)))


(define (get-wm z)
  (set! *wm-filter* z)
  (set! *wm* #f)
  (mapwm get-wm2)
  (let ((temp *wm*))
    (set! *wm* #f)
    temp))

(define (get-wm2 elem)
 (cond ((or (null? *wm-filter*) 
            (member (cdr elem) *wm-filter*))
        (set! *wm* (cons (car elem) *wm*)))))

(define (wm-hash x)
  (cond ((not x) '<default>)
        ((not (car x)) (wm-hash (cdr x)))
        ((symbolp (car x)) (car x)) ;; ops5 function
        (t (wm-hash (cdr x)))))

(define (creation-time wme)
  (let ((ret (safe-cdr (assq wme (get (wm-hash wme) 'wmpart*)))))
    (if ret
        ret
        (begin
         (display "Warning from creation-time: #f time tag for ")
         (display wme)
         (newline)
         0))))

(define (refresh)
  (set! *old-wm* #f)
  (mapwm refresh-collect)
  (mapc refresh-del *old-wm*)
  (mapc refresh-add *old-wm*)
  (set! *old-wm* #f))


(define (refresh-collect x) (set! *old-wm* (cons x *old-wm*)))

(define (refresh-del x) (remove-from-wm (car x)))

(define (refresh-add x) (add-to-wm (car x) (cdr x)))

;; Define glocal registers:

(define *c1* #f)
(define *c2* #f)
(define *c3* #f)
(define *c4* #f)
(define *c5* #f)
(define *c6* #f)
(define *c7* #f)
(define *c8* #f)
(define *c9* #f)
(define *c10* #f)
(define *c11* #f)
(define *c12* #f)
(define *c13* #f)
(define *c14* #f)
(define *c15* #f)
(define *c16* #f)
(define *c17* #f)
(define *c18* #f)
(define *c19* #f)
(define *c20* #f)
(define *c21* #f)
(define *c22* #f)
(define *c23* #f)
(define *c24* #f)
(define *c25* #f)
(define *c26* #f)
(define *c27* #f)
(define *c28* #f)
(define *c29* #f)
(define *c30* #f)
(define *c31* #f)
(define *c32* #f)
(define *c33* #f)
(define *c34* #f)
(define *c35* #f)
(define *c36* #f)
(define *c37* #f)
(define *c38* #f)
(define *c39* #f)
(define *c40* #f)
(define *c41* #f)
(define *c42* #f)
(define *c43* #f)
(define *c44* #f)
(define *c45* #f)
(define *c46* #f)
(define *c47* #f)
(define *c48* #f)
(define *c49* #f)
(define *c50* #f)
(define *c51* #f)
(define *c52* #f)
(define *c53* #f)
(define *c54* #f)
(define *c55* #f)
(define *c56* #f)
(define *c57* #f)
(define *c58* #f)
(define *c59* #f)
(define *c60* #f)
(define *c61* #f)
(define *c62* #f)
(define *c63* #f)
(define *c64* #f)
